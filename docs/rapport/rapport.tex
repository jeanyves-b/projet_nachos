%% Installer les paquets texlive-lang-french et texlive-fonts-recommended pour pouvoir compiler ce document
\documentclass{article}
\usepackage{geometry}
\geometry{
	a4paper,
	left=20mm,
	right=20mm,
	top=30mm,
	bottom=40mm,
}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

\begin{document}

\title {Rapport Projet NachOS \\ M1 Informatique}
\author{Amine Ait-Mouloud, Sébastien Avril,\\ Jean-Yves Bottraud, El Hadji Malick Diagne}
\date{Janvier 2015}
\maketitle

\section{questionnement sur le contenu/la forme du rapport}
	\\ -> faire des schema, notament pour la mémoire virtuelle et les id des threads

\tableofcontents{}
\newpage
\section{Introduction}
	Ce document représente notre rapport final dans le cadre du projet Nachos proposé pour les parcours M1 Informatique et MOSIG.
	Seront présentés dans l'ordre: 
	\begin{itemize}
		\item{}
	\end{itemize}

\section{Fonctionnalités du noyau}
	Voici les partie que nous avons réussi à implémenter jusque là :
	\begin{itemize}
		\item Appels system de lecture/écriture : toutes les fonction d'écriture et de lecture ont été portées au niveau utilisateur et sont \emph{thread safe}. Des sémaphores afin de permettre aux fonction PutString et GetString d'afficher/lire une chaine entière avant qu'une autre thread puisse écrire/lire à l'écran. Il n'y a pas de blocage entre la lecture et l'écriture.
		\item (partie 3) threads : toutes les fonctions permettant de créer, détruire et gérer des threads on été porté au niveau utilisateur.
		\item (partie 4) mémoire virtuel : le système de mémoire virtuel à été implémenté. La fonction ForkExec a été portée au niveau utilisateur.
		\item (partie 5) système de fichier : Il est maintenant possible de créer/supprimer des fichiers et des dossiers et de se déplacer dans l'architecture de dossier au niveau utilisateur. L'architecture est sauvegarder d'une éxécution à la suivante.
		\item (partie 6) réseaux : 
	\end{itemize}
	pour toutes ces parties, nos tests n'ont révélé aucun problème. Les tests effectué sont détaillé dans la section qui leur dédiés.

\section{Spécification des fonctions utilisateur}
	\subsection{Console}
		\begin{description}
			\item{SIGNATURE : } \texttt{char GetChar()}
			\item{DESCRIPTION :}{ Lis un caractère depuis l'entrée standard et le retourne sous forme de \texttt{char}. Retourne \texttt{EOF} dans la cas de la fin de fichier.}
			\item{VALEUR DE RETOUR : } Renvoie un \texttt{char} qui représente le caractère lu, ou \texttt{EOF} en cas de fin de fichier ou d'erreur.
		\end{description}
		\vspace{2.5mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{void GetString(char *s, int n)}
			\item{DESCRIPTION : } Lis au maximum \texttt{n} caractères depuis l'entrée standard jusqu'à rencontrer un caractère dit "bloquant", c'est à dire: un retour chariot (\texttt{\textbackslash{}r}), un saut de ligne (\texttt{\textbackslash{}n}), ou un caractère de fin (\texttt{\textbackslash{}0} ou \texttt{EOF}), et copie la chaine de caractères lue vers le buffer pointé par \texttt{s}. La longueur maximale d'une chaine récupérée est définie par la constante \texttt{MaxStringSize}. \\Si un caractère dit "bloquant" est rencontré, il est remplacé par l'octet nul (\texttt{\textbackslash{}0}), sinon ce dernier est placé dans l'emplacement mémoire pointé par \texttt{s+n}.
		\end{description}
		\vspace{2.5mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{int GetInt()}
			\item{DESCRIPTION : } Lis une chaîne de caractères depuis l'entrée standard selon les mêmes règles que \texttt{GetString}, la convertit en entier naturel, et retourne ce dernier.
			\item{VALEUR DE RETOUR : } Entier naturel lu depuis l'entrée standard.
		\end{description}
		\vspace{2.5mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{void PutChar(const char ch)}
			\item{DECRITPION : } Écrit le caractère \texttt{ch} sur la sortie standard. 
		\end{description}
		\vspace{3mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{void PutString(const char *s)}
			\item{DESCRIPTION : } Écrit la chaine présente dans le buffer pointé par \texttt{s} ainsi qu'un saut de ligne (\texttt{\textbackslash{}n}) sur la sortie standard. L'écriture de la chaine sur la sortie standard se poursuit jusqu'à la rencontre d'un caractère dit "bloquant", c'est à dire: un retour chariot (\texttt{\textbackslash{}r}), un saut de ligne (\texttt{\textbackslash{}n}), ou un caractère de fin (\texttt{\textbackslash{}0} ou \texttt{EOF}). La longueur maximale de la chaine à afficher est définie par la constante \texttt{MaxStringSize}
		\end{description}
		\vspace{2.5mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{void PutInt(int i)}
			\item{DESCRIPTION : } Convertit l'entier naturel \texttt{i} en chaîne de caractères et l'affiche sur la sortie standard selon les mêmes régèles que \texttt{PutString}.
		\end{description}
	\subsection{Threads}
		\begin{description}
			\item{SIGNATURE : } \texttt{int UserThreadCreate(void *f(void*), void* arg)}
			\item{DESCRIPTION : } Permet de créer un thread dans le même espace d'adressage que le thread en cours. Le thread créé lancera la fonction f donnée en paramètre avec l'argument arg. L'identifiant du thread est unique tout au long de l'exécution du processus. \\
			Le thread créé est \emph{de facto} dans le même processus que le thread dans lequel il a été créé, et est considéré comme "fils" de celui-ci. \\
			Lorsqu'un thread termine (même le thread \texttt{main}), il attend la terminaison de tous ses "fils".
			\item{VALEUR DE RETOUR : } Identifiant du thread en cas de succès, code d'erreur négatif sinon:
				\subitem{\texttt{-1} : } Raison inconnue.
				\subitem{\texttt{-2} : } Pas assez d'espace dans la pile du processus.
		\end{description}
		\vspace{2.5mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{void UserThreadExit()}
			\item{DESCRIPTION : } Termine le thread en cours d'éxecution et libère son emplacement dans la pile. Elle attend la fin de tous les threads fils de ce thread avant de terminer son exécution. Si c'est le dernier thread du processus, ce dernier se termine aussi et les ressources qu'il utilise sont libérées.
		\end{description}
		\vspace{2.5mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{int UserThreadJoin(int id)}
			\item{DESCRIPTION : } Attend que le thread ayant pour identifiant \texttt{id} se termine, et si le thread s'est déjà terminé la fonction revient de suite. Plusieurs threads peuvent attendre un même thread étant donné que l'identifiant des threads est unique dans le contexte du processus.
			\item{VALEUR DE RETOUR : } \texttt{0} en cas de succès, code d'erreur négatif sinon:
				\subitem{\texttt{-1}, \texttt{-2} : } Identifiant fourni introuvable (jamais créé ou négatif).
				\subitem{\texttt{-3} : } Tentative d'attendre le thread en cours d'exécution.
		\end{description}
		\vspace{2.5mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{int GetTid()}
			\item{DESCRIPTION : Renvoie le l'identifiant du thread en cours d'exécution. Cet identifiant n'est unique que dans le contexte de son processus.} 
			\item{VALEUR DE RETOUR : }
				\subitem{\texttt{>0} : } L'execution s'est passé correctement et la valeur retournée correspond au Pid du process en cours.
				\subitem{\texttt{} : }
		\end{description}
	\subsection{Mémoire virtuelle}
		\begin{description}
			\item{SIGNATURE : } \texttt{int ForkExec(char *path)}
			\item{DESCRIPTION : } Crée un nouveau processus dans un environnement vide, et y exécute le fichier exécutable dont le nom est pointé par \texttt{path}.
			\item{VALEUR DE RETOUR : } Identifiant du processus créé en cas de succès, code d'erreur négatif sinon:
				\subitem{\texttt{-1} : } Impossible d'ouvrir le fichier présent à l'emplacement décrit dans le buffer pointé par \texttt{path}.
				\subitem{\texttt{-2}, \texttt{-4} : } Impossible de créer un environnement d'exécution.
				\subitem{\texttt{-3} : } Pas assez de pages libres en mémoire pour créer l'espace d'adressage du processus.
		\end{description}
		\vspace{2.5mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{int GetPid()}
			\item{DESCRIPTION : } Renvoie le l'identifiant du processus en cours d'exécution dans le contexte de l'exécution en cours.
			\item{VALEUR DE RETOUR : }
				\subitem{\texttt{>0} : } L'execution s'est passé correctement et la valeur retournée correspond au Pid du process en cours.
				\subitem{\texttt{} : }
		\end{description}
		
	\subsection{Système de fichiers}
		\begin{description}
			\item{SIGNATURE : } \texttt{int mkdir(char *name)}
			\item{DESCRIPTION : } Crée un répertoire portant le nom *name dans le répertoire courrant.
			\item{VALEUR DE RETOUR : } 
				\subitem{\texttt{0} : } L'opération a échoué. Le chemin spécifié n'existe pas, soit on ne peux plus ajouter d'élément dans le dossier courant.
				\subitem{\texttt{1} : } L'opération s'est dérouler correctement.
		\end{description}
		\vspace{2.5mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{int rmdir(char *name)}
			\item{DESCRIPTION : } Supprime le répertoire portant le nom *name du répertoire courrant. Si le dossier n'est pas vide, cette fonction retournera une erreur.
			\item{VALEUR DE RETOUR : } 
				\subitem{\texttt{0} : } L'opération a échoué. le dossier à supprimer est introuvable ou bien le répertoire n'est pas vide.
				\subitem{\texttt{1} : } L'opération s'est dérouler correctement.
		\end{description}
		\vspace{2.5mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{int mkfile(char *name, int initialsize)}
			\item{DESCRIPTION : } 
			\item{VALEUR DE RETOUR : } 
				\subitem{\texttt{0} : } L'opération a échoué. le dossier contient déjà 8 fichiers, un fichier du même nom existe déjà, ou bien il n'y a plus de place sur le disque.
				\subitem{\texttt{1} : } L'opération s'est dérouler correctement.
		\end{description}
		\vspace{2.5mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{int rmfile(char *name)}
			\item{DESCRIPTION : } 
			\item{VALEUR DE RETOUR : } 
				\subitem{\texttt{0} : } L'opération a échoué. Il n'y a pas de fichier de ce nom dans le répertoire courrant.
				\subitem{\texttt{1} : } L'opération s'est dérouler correctement.
		\end{description}
		\vspace{2.5mm}
		\begin{description}
			\item{SIGNATURE : } \texttt{int cd(char *name)}
			\item{DESCRIPTION : } 
			\item{VALEUR DE RETOUR : } 
				\subitem{\texttt{0} : } L'opération a échoué. Le dossier de destination est introuvable ou bien il ne peux pas être ouvert.
				\subitem{\texttt{1} : } L'opération s'est dérouler correctement.
		\end{description}
		\vspace{2.5mm}
	
	\subsection{Réseau}
		\begin{description}
			\item{SIGNATURE : } \texttt{int Send(..)}
			\item{DESCRIPTION : } 
			\item{VALEUR DE RETOUR : } 
				\subitem{\texttt{-1} : } 
				\subitem{\texttt{-2} : } 
				\subitem{\texttt{-3} : } 
		\end{description}
		\vspace{2.5mm}

\section{Test}
	\subsection{Organisation}
		{Pour automatiser les tests, nous avons décidé de créer un script qui va lancer nos fichier de test au travers du projet.
		Nous avons essayer de faire suffisamment de tests pour tester tous les défauts possible du programme, ils sont répartis en une série de fichiers séparé par étape du projet dans des dossiers correspondant au numéro de l'étape. Tous ces dossiers sont situé dans code/test.}

	\subsection{Utilisation}
		{Pour lancer les tests, ils suffit d'exécuter le script testpart.sh situé dans le dossier code/test}

	\subsection{Tests effectués et comportements}
		\subsubsection{Console}
			\begin{itemize}
				\item Une chaine de 1 caractères 			validé : écrit le caractère	correctement à l'écran ou bien dans le fichier de destination
				\item Utilisation de la console				validé : la console réécrit tout ce qui est tappé correctement
				\item Ecriture/lecture parallèle			validé : possibilité de faire des caractère entrelacé avec putchar ou bien des string continue avec putstring
				\item Trop de caractères					validé : sépare la chaine écrire en plusieurs chaines de taille équivalante à taillemax (situer dans le fichier .cc)
				\item Pas de caractère 						validé : si rien n'est entrée, rien ne se passe et si on entre juste le caractère retour chariot, il est traité comme n'importe quelle lettre
				\item Arrêt avec EOF 						validé : arrete la lecture de fichier.
			\end{itemize}

		\subsubsection{Thread}
			\begin{itemize}
				\item Création d'un thread :
					\subitem Création courante 				validé : le thread se crée
					\subitem Possibilités d'échecs	validé : retourne la bonne erreur
					\subitem Très grand nombre de threads 				validé : crée le threads normalement jusqu'au moment ou l'on dépasse le nombre maximum de threads. A partir ce cette limite, la fonction retourne une erreur.
				\item Arreter un thread avec Exit :
					\subitem Vérifier les fuites mémoires		validé : toutes les structures allouées sont bien supprimées
					\subitem Plus dans l'ordonanceur			validé : l'ordonnanceur n'essaie plus de donner la main à la thread
					\subitem Etat du parent					validé : le parent n'a plus le thread courant dans sa liste et continue de touner correctement
					\subitem Etat des enfants					validé : on attend la fin des enfants avant de supprimer la thread courante. Ce choix est détaillé dans la partie "choix d'implémentation".
				\item Lancement d'une fonction		validé : testé avec les fonctions disponible, elles sont effectuées correcetement
				\item Retours d'erreurs				validé : quand les mauvais argument sont passé à la fonction ou bien qu'il n'y a plus assez de place pour créer un thread, la fonction renvoie bien le bon code d'erreur.
			\end{itemize}

		\subsubsection{Mémoire virtuelle}
			\begin{itemize}
				\item Créer un processus :					validé : le processus est créé correctement et la fonction passée en paramètre démarre normalement.
				\item Stress de la mémoire :				validé : les fichiers matmult et sort s'éxécutent sans problèmes.
				\item Allocation et libération de pages : 	validé : les pages sont alloué et libérée correctement. les pages ne sont pas donnée alors qu'elles sont utilisé et ne sont libérée qu'à la fin des processus.
				\item Caractères entrelacé avec processus : ???
				\item Retours d'erreurs : 					validé : les bonnes valeur sont retourné en cas de mauvais arguments ou de manque de place.
			\end{itemize}

		\subsubsection{système de fichier}
		Ces fonctions ont été testées à partir d'appel système car nous n'avons pas implémenté de shell pratique et rapide.
			\begin{itemize}
				\item Créer un dossier/fichier :				validé : Le dossier/fichier est créer et est accessible.
				\item Déplacement vers un dossier parent/fils :	validé : On peux se déplacer à volonter dans les dossiers.
				\item Suppression dossier/fichier :				validé : Le dossier/fichier est supprimé correctement. Les pages sont libéré et il ne réapparait pas lors de la prochaine lecture du disque.
				\item Enregistrement de la structure :			validé : La structure s'enregistre correctement et est rechargée sans erreur notable au début de l'éxécution de la machine.
			\end{itemize}

		\subsubsection{Réseau}
			\begin{itemize}
				\item Test en anneau. On crée plusieurs machines qui vont recevoir le fichier, le modifier de façon prédictible, puis le renvoyer à la prochaine machine. Validé : le fichier reçu est correcte et il est renvoyé à la bonne machine.
				\item Envoie/réception de fichier : fichier envoyé et reçu puis enregistré correctement.
			\end{itemize}

\section{Choix d'implémentation}
	\subsection{Console}
	    {Le but de cette section est la mise en place des entrées/sorties de niveau utilisateur. Pour cela, nous avons due créer 2 appel systèmes et quelques fonctions utilisateurs. Les appels système appelent les descriptions des fonctions utilisateurs. Cette section étant très guidée dans le sujet, nous n'avons eu aucun choix d'implémentation particulier.
	    Nous avons sécurisé des lecture/écriture pour le multithreading. les fonctions de lectures (GetInt, GetChar et GetString) ne peuvent plus s'intérompre les une les autres et les fonctions d'écritures (PutChar, PutInt et PutString) ne s'intérompent plus les unes les autre non plus. Mais les fonctions d'écriture peuvent intérompre les fonction de lecture et inversement.}

	\subsection{Threads}
		\subsubsection{La structure thread}
			\begin{itemize}
				\item id : son id, permetant d'acceder à son adresse mémoire
				\item liste de tout ses fils : utilisé pour faire une join sur les fils au moment de UserThreadExit
			\end{itemize}
		\subsubsection{Gestion des identifiants de threads et de la pile}
			{Deux identifiants:}
			\begin{itemize}
				\item{un identifiant unique: unique parmi tous les threads du processus.}
				\item{un identifiant en pile : pour les processus actifs.}
			\end{itemize}
			{La pile est divisée en un nombre de blocs déterminé par le nombre de pages par thread. l'identifiant en pile représente le numéro du bloc de la pile qui est alloué au thread. Les blocs de pile sont numérotés de 0 à N: N étant le bloc ayant l'adresse de pile la plus petite, et 0 le bloc ayant l'adresse la plus grande. Un thread demande un bloc en pile à sa création, et le libère lorsque se termine. \\
			Afin de stocker les identifiants uniques et les identifiants en pile des threads, on utilise un tableau de taille N (nombre maximal de threads dans un processus), où chaque numéro de case représente un bloc en pile, et le contenu de la case représente l'identifiant unique du thread qui est alloué actuellement dans ce bloc en pile (si positif ou nul), ou que ce dernier n'est pas alloué (négatif, -1).\\
			Afin de tester l'état d'un thread ayant pour identifiant unique \texttt{x}, on utilise les algorithmes suivants: }
				\begin{itemize}
					\item{\texttt{x} est supérieur au nombre de threads créés: } Le thread n'a jamais été créé ;
					\item{\texttt{x} est inférieur au nombre de threads créés, mais n'est pas présent dans le tableau: } Le thread a été créé, mais s'est terminé ;
					\item{\texttt{x} est inférieur au nombre de threads créés, et est présent dans le tableau à la case \texttt{i} : Le thread a été créé, et est en cours d'exécution, et le bloc en pile numéro \texttt{i} lui est alloué.}
				\end{itemize}
		\subsubsection{Implementation du join}
			structures : vecteur séquentiel contenant la liste des threads en attente et l'identifiant des threads qu'ils attend
				\begin{itemize}
					\item élement who : Thread qui attend
					\item élement forId : identifiant du thread que who doit attendre
				\end{itemize}
			dès l'appel à join du thread d'id x, on ajoute la paire (thread courant, x) à la liste des threads en attente et le thread courant appel la fonction Sleep. Elle l'enlevera de la liste d'attente du scheduler pour ne pas le réveiller inutilement, c'est le thread sur lequel le join a été effectué qui reveillera ce thread lors de son appel a UserThreadExit

	\subsection{Mémoire virtuelle}
		\subsubsection{Pagination mémoire}
			le frame provider, utilise une bitmap et toutes les fonction implémentées pour celle-ci. La fonction de recherche d'un bit vide nous est utilisé pour aller chercher une page vide et son adresse. Et la fonction retournant le nombre de bit a 0 est utilisé pour avoir le nombre de page libre. La fonction libérant les pages utilise la fonction des bitmaps pour libérer le bit correspondant dans la bitmap.\\
			nous avons pu remarqué qu'avec la façon dont nous avons implémenté notre table de page : ppn (physical page number) = vpn (virtual page number) + 128 (taille d'une page)
				-> ceci est une faille de sécurité car elle permet de faire d'aller écrire à des endroit où l'on ne devrait pas pouvoir.
				-> cette implémntation permet tout de même d'avoir tous les autres avantages des pages virtuelles\\
			Lorsque quelque chose demande de la mémoire (création d'un process, enregistrement d'un fichier...), la bitmap nous donne une adresse puis l'adresse de la page est donée au programme pour qu'il puisse y inscrire ce dont il a besoin.\\
			Lors de la fin du programme, la(les) page(s) est déclarée(s) vide et le bit correspondant est remit à 0.
		\subsubsection{Implémentation de Fork et ForkExec}
			{Ces deux fonctions sont inspiré de StartProcess. Elles font appel à l'appel system \texttt{do\_UserProcessCreate}. ce dernier va ouvrir l'executable, lui allouer de la mémoire (un addrspace). Il va ensuite créer le thread et y attacher la mémoire allouée. Il va enfin mettre à jour le nombre de processus créés.
			\\ /!/ForkExec le thread créé sur StartUserProcess/!/
			\\ La différence entre ForkExec et Fork est que ForkExec ne mets pas la mémoire à la même adresse que celle du thread en cours.
			\\ Avant de se fermer, la machine attend la fin du dernier process. Pour savoir si le processus actuel est le dernier, la machine garde un compteur du nombre de processus en cours de fonctionement, qui est incrémenté quand un process est créer et qui est décrémenté quand un process se termine. Le dernier process est donc celui qui met le compteur a $0$ en se terminant.}

	\subsection{système de fichier}
la position dans les dossier n'est pas sauvegarder entre deux éxécutions.
lorsque la machine s'arrète, on reviens à la racine.

	\subsection{réseaux}
		Une tentative d'envoi ne se termine que lorsqu'il un message reçoit son acquittement ou qu'il ait été renvoyé (TEMPO*MAXREEMISSIONS) fois. ON ne peu attendre de message d'acquitement que pour un seul message à la fois. Pour ce faire, on utikisse un deamon qui est bloqué au départ, puis lancé dès que l'on tente d'envoyer un message puis rebloqué lorsque la tentative se fini.
		le type du message est précisé dans son header. Il peux s'agir soit d'un message normal (MSG), soit d'un message d'acquitement (ACK)
		la faiblesse de ce système est que les sygnaux d'acquitement peuvent être perdu facilement. Par exemple si une machine s'éteint en ayant envoyé un ACK qui sera perdu, l'expéditeur retentera d'envoyer le message à l'infini.
		pour transferer les fichiers, un premier paquet est envoyé contenant la taille du fichier à envoyer. puis l'envoie est fragmenté en plusieurs paquets de MaxStringSize si la taille du fichier supérieure à cette limite utilisateur. Le récépteur met tous les paquet dans un buffer dont la taille est définie par le contenu du premier paquet, pusi écrit le contenu du buffer dans un fichier.
		

\section{Organisation du travail}
	\subsection{Fonctionement du groupe}
		Malik : code/debug/docs\\
		Amine : code/docs\\
		Sebastien : code/docs\\
		Jean-Yves : organisation/docs/tests\\

	\subsection{Planning}
	\begin{itemize}
		\item semaine 1 :
			\subitem mise en place du projet
			\subitem nous avons commencé par faire la partie 1 chacun de notre coté,
			\subitem puis nous avons tous travaillé ensemble sur les parties 2 puis 3.

		\item semaine 2 :
			\subitem cette semaine, nous avons commencer par finir la partie 3
			\subitem puis nous avons enchainé sur la partie 4.

		\item semaine 3 :
			\subitem Malik : partie 5
			\subitem Amine : partie 6
			\subitem Sebastien : débug partie 4 et 5
			\subitem Jean-Yves : travail de mise en page et avancement du rapport

		\item semaine 4 :
			\subitem lundi/mardi : fin des partie 5 et 6 et debug du reste
			\subitem mercredi : fin du rapport (mise en page + schema + correction de contenu) et préparation du contenu de la présentation
			\subitem jeudi : entrainement pour la présentation
			\subitem vendredi : D-day
	\end{itemize}

\end{document}
