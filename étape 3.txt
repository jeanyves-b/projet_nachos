travail en cours :
	user thread join

reste à faire :
	do exit à modifier pour tuer les fils
	test unitaire
	partie 3

partie 1:
structure thread
	son id
		permet d'acceder à son adresse mémoire
	liste de tout ses fils
		utilisé pour tuer les fils au moment de UserThreadExit

	les threads noyaux sont créer en créant une nouvelle structure thread et en la mettant dans l'ordonanceur
	choix d'implementation :
		comment passer les informations aux threads :
			on crée une fonction StartUserThread qui prend en paramètre un entier
			l'entier en paramètre sera une adresse vers une structure de type FunctionData
			la structure FunctionData contient:
				adresse de la fonction à éxecuter
				adresse de l'argument de la fonction à éxecuter
				identifiant du thread à créer
		comment il est ajouter dans l'ordonanceur (début/fin/milieu...) :
			fork qui s'en occupe
		exit d'un thread (appel de thread::finish + cleanup) :
			libération des blocs de pile alloué au thread
			demander au thread de se terminer
		gestion des identifiants de threads: dans l'espace d'adressage (pile)
			deux identifiants:
				un identifiant unique: unique parmi tous les threads du processus
				un identifiant en pile: pour les processus actifs
					la pile est divisée en un nombre de blocs déterminé par le nombre de pages par thread
					l'identifiant en pile représente le numéro du bloc de la pile qui est alloué au thread
			structures de stockages des identifiants:
				un tableau d'identifiants de pile où chaque case représente pris par un thread (true) ou pas (false) dans la pile
					un thread demandera un espace dans la pile à sa création, et le liberera à sa fin
					l'identifiant en pile d'un thread sera le numéro de la case qui lui sera attribuée dans ce tableau
						possibilité de calculer l'emplacement de la pile d'un thread dans l'espace d'adressage à partir de son identifiant en pile
				un tableau dont la clé est l'identifiant unique, et le contenu l'identifiant en pile + 2 (x)
					x=0 veut dire qu'aucun thread portant cet identifiant unique n'a jamais été créé
					x=1 veut dire qu'un thread portant cet identifiant unique a été créé, mais a quitté
					x=2+ veut dire que le thread ayant cet identifiant unique est en cours d'execution, et sa pile est dans le bloc (x - 2)

	raison du plantage d'un thread POSIX (penser a mettre un DEBUG).
		impossibilité de créer un thread
			new Thread() échoue
		pas assez de ressources
			pas assez d'espace restant dans la pile
		mauvais argument
			sécuriser si la fonction ou l'argument pointe dans le vide
			??
		pas la permission de créer un thread (possible?)
			??

	do_UserThreadCreate
		va appeler la fonction UserThreadCreate au niveau noyaux et lui allouer ce dont elle a besoin
		initilialisera tous les registres à 0
		mettra le registre compteur à l'adresse de la fonction à exécuter par le thread
			(mettra le registre NextPC fonction+4)
		mettre le registre de pile à l'emplacement de l'espace de pile reservé au thread
			calculable selon l'identifiant en pile du thread, la taille de la pile, la taille d'une page et le nombre de pages allouées à un thread
			

	StartUserThread
		passage de "arg"
			//dit plus haut dans "comment passer les infos à un thread"

	do_UserThreadExit
		tue la thread et nettoie sont espace de travail
		doit attendre la fin de tous les threads lié à ce thread
			!!pas encore fait

	tester!
		création d'un thread
			tester toutes les possibilités d'échecs (voir plus haut)
		arreter un thread "proprement"
			vérifier les fuites mémoires
			plus dans l'ordonanceur
			état du parent, et des enfants.
		effectue correctement une fonction
			tester avec les fonctions disponible


partie 2:
	!assertion violation!, protéger les requètes décriture et de lecture noyau avec un verroux
	dans SynchConsole, mettre un mutex/semaphore pour l'écriture et la lecture (pas déjà le cas avec le sémaphore? partage du sémaphore(static sémaphore)? à tester)
	mettre un mutex sur les pustring et putchar

	thread initial quite, qu'est-ce qui se passe?
		tout est tué mais proprement
		un tableau dans la structure thread définie les thread crées à partir de ces thread. sert à les fermer quand le thread parent fini.
		/!\ à ce qu'elle ne soie pas modifiée par plusieur thread en même temps.
	appel unique de UserThreadCreate? ->non mais pour le moment toutes les thread sont au même niveau (pas de différenciation parent/enfant)

	plusieurs threads lancés en même temps?
		/!\ pas de SaveState/restoreState fonction a définir pour que les threads puissent reprendre au bon endroit. Jamais implémenté dans les autres programes, sont-elles bien utiles? -> les thread utilisateur peuvent-ils perdre la main?

	très grand nombre de threads?
		retourne une erreur
		mémoire en fonction du besoin : allouer des pages si besoin de plus de mémoires -> impossible
			doit retourner une erreur en cas de dépasement de la mémoire allouer
			taille de mémoire à définir au départ -> choix de la taille allouer de base

	UserThreadJoin
		structures:
			vecteur séquentiel contenant la liste des threads en attente et l'identifiant des threads qu'ils attend
				élement who: Thread qui attend
				élement forId: identifiant du thread que who doit attendre
		dès l'appel à join du thread d'id x
			on ajoute la paire (thread courant,x) à la liste des threads en attente 
			appel à Sleep pour le thread courant
				Sleep l'enlevera de la liste d'attente du scheduler
		à l'appel de Exit par n'importe quel thread d'id y
			trouver les couples (t,y) ou t est n'importe quel thread
			remettre t sur la liste d'attente du scheduler			
			désallouer la structure pour libérer la mémoire
	
		#tableau de sémaphore
		#id sert d'identifiant dans ce tableau
		#pour attendre, on attend le sémaphore

		(suite)
		attente mutuel
		ne pas attendre le bon thread

	
partie 3 bonus (à revenir dessus, pour le moment ce n'est pas une priorité)
