reste à faire :
	test unitaire
	partie 3

partie 1:
	les threads noyaux sont créer en créant une nouvelle structure thread et en la mettant dans l'ordonanceur
	choix d'implementation :
		comment passer les informations aux threads :
		comment il est ajouter dans l'ordonanceur (début/fin/milieu...) :
		exit d'un thread (appel de thread::finish + cleanup) :

	raison du plantage d'un thread (penser a mettre un DEBUG).
		pas assez de ressources
		plus de thread disponible
		mauvais argument
		pas la permission de créer un thread

	do_UserThreadCreate
		va appeler la fonction UserThreadCreate au niveau noyaux et lui allouer ce dont elle a besoin

	StartUserThread
		passage de "arg"

	do_UserThreadExit
		tue la thread et nettoie sont espace de travail
		doit attendre la fin de tous les threads lié à ce thread

	tester!
		création d'un thread
			tester toutes les possibilités d'échecs (voir plus haut)
		arreter un thread "proprement"
			vérifier les fuites mémoires
			plus dans l'ordonanceur
			état du parent, et des enfants.
		effectue correctement une fonction
			tester avec les fonctions disponible

partie 2:
	!assertion violation!, protéger les requètes décriture et de lecture noyau avec un verroux
	dans SynchConsole, mettre un mutex/semaphore pour l'écriture et la lecture (pas déjà le cas avec le sémaphore? partage du sémaphore(static sémaphore)? à tester)
	mettre un mutex sur les pustring et putchar

	thread initial quite, qu'est-ce qui se passe?
		tout est tué mais proprement
		rajouter une variable comptant le nombre de thread dérivé et attendre qu'elle vale 0 avant de quitter, unr variable par thread
		/!\ à ce qu'elle ne soie pas modifiée par plusieur thread en même temps.
	appel unique de UserThreadCreate

	plusieurs threads lancés en même temps?
		/!\ pas de SaveState fonction a définir pour que les threads puissent reprendre au bon endroit.
		section critique dans la création de threads?

	très grand nombre de threads?
		retourne une érreur
		mémoire en fonction du besoin
			allouer des pages si besoin de plus de mémoires

	UserThreadJoin
		tableau de sémaphore
		id sert d'identifiant dans ce tableau
		pour attendre, on attend le sémaphore
	
partie 3 bonus (à revenir dessus, pour le moment ce n'est pas une priorité)